"""
Eoles Model from Behrang Shirizadeh, Quentin Perrier and Philippe Quirion, May 2021
Written in Python by Nilam De Oliveira-Gill, June 2021
"""

import pyomo.environ as pyo
from pyomo.opt import SolverFactory
import pandas as pd
import csv
import time
import sys

number_of_years = 9
# Initialize time
#start_time = time.time()
# Redirect stdout
#sys.stdout = open("stdout.txt", 'a')

"""INITIALISATION MODEL"""

model = pyo.ConcreteModel()

# Dual Variable, used to get the marginal value of an equation.
model.dual = pyo.Suffix(direction=pyo.Suffix.IMPORT)

"""INPUTS"""
# Production profiles of VRE
#load_factor = pd.read_csv("inputs/vre_obs_pv_wind.csv", index_col=[0, 1], header=None)
#load_factor = load_factor.squeeze()

# Demand profile in each our in GW
demand = pd.read_csv("inputs/demand_2012_2020.csv", index_col=0, header=None)
demand = demand.squeeze()

# Monthly lake inflows in GWh
lake_inflows = pd.read_csv("inputs/lake2006_nine.csv", index_col=0, header=None)
lake_inflows = lake_inflows.squeeze()

# existing capacities of the technologies by December 2017 in GW
capa_ex = pd.read_csv("inputs/existing_capas_elec_new_NoOffshore_voll.csv", index_col=0, header=None)
capa_ex = capa_ex.squeeze()

# maximum capacities of the technologies in GW
capa_max = pd.read_csv("inputs/max_capas_elec_new_NoOffshore.csv", index_col=0, header=None)
capa_max = capa_max.squeeze()

# annualized power capex cost in M€/GW/year
capex = pd.read_csv("inputs/annuities_elec_new_NoOffshore_voll.csv", index_col=0,  header=None)
capex = capex.squeeze()

# annualized energy capex cost of storage technologies in M€/GWh/year
capex_en = pd.read_csv("inputs/str_annuities_elec_new.csv", index_col=0,  header=None)
capex_en = capex_en.squeeze()

# annualized fixed operation and maintenance costs M€/GW/year
fOM = pd.read_csv("inputs/fO&M_elec_new_NoOffshore_voll.csv", index_col=0,  header=None)
fOM = fOM.squeeze()

# Variable operation and maintenance costs in M€/GWh
vOM = pd.read_csv("inputs/vO&M_elec_new_NoOffshore_voll.csv", index_col=0,  header=None)
vOM = vOM.squeeze()

# charging related annuity of storage in M€/GW/year
s_capex = pd.read_csv("inputs/s_capex.csv", index_col=0, header=None)
s_capex = s_capex.squeeze()

# charging related fOM of storage in M€/GW/year
s_opex = pd.read_csv("inputs/s_opex.csv", index_col=0, header=None)
s_opex = s_opex.squeeze()

# charging efficiency of storage technologies
eta_in = pd.read_csv("inputs/eta_in.csv", index_col=0, header=None)
eta_in = eta_in.squeeze()

# discharging efficiency of storage technolgoies
eta_out = pd.read_csv("inputs/eta_out.csv", index_col=0, header=None)
eta_out = eta_out.squeeze()

# existing storage capacity in GWh
capacity_ex = pd.read_csv("inputs/capacity_ex.csv", index_col=0, header=None)
capacity_ex = capacity_ex.squeeze()

#Installed capacity
capa = pd.read_csv('inputs/Installed_capacity_sys_ref.csv', index_col=0, header=None)
capa = capa.squeeze()

#Volume of the storage
capacity = pd.read_csv('inputs/vol_ref_sys.csv', index_col=0, header=None)
capacity = capacity.squeeze()

# charging capacity
s = pd.read_csv('inputs/s_ref_sys.csv', index_col=0,  header=None)
s = s.squeeze()

# Parameters in miscellaneous.csv :
# eta_ocgt                  : efficiency of OCGT power plants
# eta_ccgt                  : efficiency of CCGT power plants with CCS
# max_biogas                : maximum energy can be generated by biogas in TWh
# load_uncertainty          : uncertainty coefficient for hourly demand
# delta                     : load variation factor
# phs_discharging_lower     : lower bounds for capa(phs)
# phs_discharging_upper     : upper bounds for capa(phs)
# phs_charging_lower        : lower bounds for s(phs)
# phs_charging_upper        : upper bounds for s(phs)
# phs_energy_lower          : lower bounds for capacity(phs)
# phs_energy_upper          : upper bounds for capacity(phs)
# first_month               : first month of demand
# first_year                : first year of demand

miscellaneous = pd.read_csv("inputs/miscellaneous_noHdemand.csv", index_col=0,  header=None)
miscellaneous = miscellaneous.squeeze()
"""SET HOUR BY MONTHS

Take the number of hour in the demand file.
Set up hours per months. Take care of leap years."""

first_year = miscellaneous['first_year']
first_month = miscellaneous['first_month']
first_hour = 0
last_hour = len(demand)
days_in_feb = 672
if first_year % 4 == 0:
    days_in_feb = 696

months_count = 12*number_of_years

hours_by_months = {1: 744, 2: days_in_feb, 3: 744, 4: 720, 5: 744, 6: 720, 7: 744, 8: 744, 9: 720, 10: 744, 11: 720,
                   12: 744}
months_hours = {1: range(0, 744), 2: range(744, 1440), 3: range(1440, 2184), 4: range(2184, 2904),
                5: range(2904, 3648), 6: range(3648, 4368), 7: range(4368, 5112),
                8: range(5112, 5856), 9: range(5856, 6576), 10: range(6576, 7320), 11: range(7320, 8040),
                12: range(8039, last_hour)}
i = 1
j = first_month
hour = 0

while i <= months_count:
    months_hours[i] = range(hour, hour + hours_by_months[j])
    hour += hours_by_months[j]
    j += 1
    i += 1
    if j == 13:
        j = 1

"""SETS"""

# Range of hour in one year
model.h = \
    pyo.RangeSet(first_hour, last_hour - 1)
# Months
model.months = \
    pyo.RangeSet(1, months_count)
# Technologies
model.tec = \
    pyo.Set(
        initialize=["onshore", "pv_g", "pv_c", "river", "lake", "biogas2", "ccgt", "nuc",
                    "phs", "battery4"])
#Technology no vre
model.tec_no_vre = \
    pyo.Set(
        initialize=["lake", "biogas2", "ccgt", "nuc","phs", "battery4"])

# Power plants
model.gen = \
    pyo.Set(initialize=["onshore", "pv_g", "pv_c", "river", "lake","ccgt", "nuc"])
# Variables Technologies
model.vre = \
    pyo.Set(initialize=["onshore", "pv_g", "pv_c", "river"])
#
model.balance = \
    pyo.Set(
        initialize=[ "lake", "nuc", "phs", "battery4", "ccgt"])
# Storage Technologies
model.str = \
    pyo.Set(initialize=["phs", "battery4"])
# Storage Technologies
model.str_noH2 = \
    pyo.Set(initialize=["phs", "battery4"])
# Battery Storage
model.battery = \
    pyo.Set(initialize=[ "battery4"])



""""Bound Constraints"""

capa_dict = capa.to_dict().copy()
capacity_dict = capacity.to_dict().copy()
s_dict = s.to_dict().copy()


def generation_bounds(model, i, h):
    return (None, capa_dict[i])

#charging power capacity of the battery
def str_ch_p_bounds(model,i,h):
        return (None, s_dict[i])

#charging power capacity of the battery
def str_capacity_bounds(model,i,h):
        return (None, capacity_dict[i])

"""VARIABLES"""

# Hourly energy generation in GWh/h
model.gene = \
    pyo.Var(((tec, h) for tec in model.tec for h in model.h), within=pyo.NonNegativeReals, bounds=generation_bounds,initialize=0)


# Hourly electricity input of battery storage GW
model.storage = \
    pyo.Var(((storage, h) for storage in model.str for h in model.h), within=pyo.NonNegativeReals,bounds=str_ch_p_bounds ,initialize=0)

# Energy stored in each storage technology in GWh = Stage of charge
model.stored = \
    pyo.Var(((storage, h) for storage in model.str for h in model.h), within=pyo.NonNegativeReals,bounds=str_capacity_bounds ,initialize=0)

# Energy stored in each storage technology in GWh = Stage of charge
model.ll = \
    pyo.Var((h for h in model.h), within=pyo.NonNegativeReals, initialize=0)


"""CONSTRAINTS RULE"""


def combustion_2_constraint_rule(model, h):
    """Get constraint on the relationship of combustible technologies

    :param model: Model.
    :param h: Timestamp.
    :type model: :py:class:`pyomo.Model`
    :type h: :py:class:`pyomo.Set`

    :returns: Expression.
    """
    return model.gene['ccgt', h] == model.gene['biogas2', h] * miscellaneous['eta_ccgt']



def storing_constraint_rule(model, h, storage_tecs):
    """Get constraint on storing.

    :param model: Model.
    :param h: Timestamp.
    :param storage_tecs: Storage Technologies.
    :type model: :py:class:`pyomo.Model`
    :type h: :py:class:`pyomo.Set`
    :type storage_tecs: :py:class:`pyomo.Set`

    :returns: Expression.
    """
    hPOne = h + 1 if h < (last_hour - 1) else 0
    charge = model.storage[storage_tecs, h] * eta_in[storage_tecs]
    discharge = model.gene[storage_tecs, h] / eta_out[storage_tecs]
    flux = charge - discharge
    return model.stored[storage_tecs, hPOne] == model.stored[storage_tecs, h] + flux


def storage_constraint_rule(model, storage_tecs):
    """Get constraint on stored energy to be equal at the end than at the start.

    :param model: Model.
    :param storages_tecs: Storage Technology.
    :type model: :py:class:`pyomo.Model`
    :type storage_tecs: :py:class:`pyomo.Set`

    :returns: Expression.
    """
    first = model.stored[storage_tecs, first_hour]
    last = model.stored[storage_tecs, last_hour - 1]
    charge = model.storage[storage_tecs, last_hour - 1] * eta_in[storage_tecs]
    discharge = model.gene[storage_tecs, last_hour - 1] / eta_out[storage_tecs]
    flux = charge - discharge
    return first == last + flux


def lake_reserve_constraint_rule(model, month):
    """Get constraint on maximum monthly lake generation.

    :param model: Model.
    :param month: Month.
    :type model: :py:class:`pyomo.Model`
    :type month: int

    :returns: Expression.
    """
    return sum(model.gene['lake', hour] for hour in months_hours[month]) <= lake_inflows[month] * 1000



def biogas_constraint_rule(model):
    """Get constraint on biogas.

    :param model: Model.
    :type model: :py:class:`pyomo.Model`

    :returns: Expression.
    """
    gene_biogas = sum(model.gene['biogas2', hour] for hour in model.h)

    return gene_biogas <= miscellaneous['max_biogas'] * 1000*number_of_years




def adequacy_constraint_rule(model, h):
    """Get constraint for 'supply/demand relation'

    :param model: Model.
    :param h: Timestamp.
    :type model: :py:class:`pyomo.Model`
    :type h: :py:class:`pyomo.Set`

    :returns: Expression.
    """
    gene_vre = sum(capa[vre] * load_factor[vre, h] for vre in model.vre)
    sto = sum(model.storage[str_noH2, h] for str_noH2 in model.str_noH2)
    return model.ll[h] + gene_vre + sum(model.gene[balance, h] for balance in model.balance) >= (demand[h] + sto )


def objective_rule(model):
    """Get constraint for the final objective function.

    :param model: Model.
    :type model: pyomo.Model

    :returns: Expression.
    """

    return (sum(model.ll[h]*10 for h in model.h)+sum((capa[tec] - capa_ex[tec]) * capex[tec] * number_of_years for tec in model.tec) \
            + sum((capacity[storage_tecs] - capacity_ex[storage_tecs]) * capex_en[storage_tecs] * number_of_years
                  for storage_tecs in model.str) \
            + sum(capa[tec] * fOM[tec] * number_of_years for tec in model.tec) \
            + sum(s[storage_tecs] * (s_opex[storage_tecs] + s_capex[storage_tecs]) * number_of_years for
                  storage_tecs in model.str) \
            + sum(sum(model.gene[tec, h] * vOM[tec] for h in model.h) for tec in model.tec)) / 1000

fixed_cost = (sum((capa[tec] - capa_ex[tec]) * capex[tec] * number_of_years for tec in model.tec) \
            + sum((capacity[storage_tecs] - capacity_ex[storage_tecs]) * capex_en[storage_tecs] * number_of_years
                  for storage_tecs in model.str) \
            + sum(capa[tec] * fOM[tec] * number_of_years for tec in model.tec) \
            + sum(s[storage_tecs] * (s_opex[storage_tecs] + s_capex[storage_tecs]) * number_of_years for
                  storage_tecs in model.str))/1000

variable_cost = sum(sum(model.gene[tec, h] * vOM[tec] for h in model.h) for tec in model.tec)/ 1000
ll_cost = sum(model.ll[h]*10 for h in model.h)/1000
"""CONSTRAINT CREATION"""



model.combustion_2_constraint = \
    pyo.Constraint(model.h, rule=combustion_2_constraint_rule)
model.storing_constraint = \
    pyo.Constraint(model.h, model.str, rule=storing_constraint_rule)
model.storage_constraint = \
    pyo.Constraint(model.str, rule=storage_constraint_rule)
model.lake_reserve_constraint = \
    pyo.Constraint(model.months, rule=lake_reserve_constraint_rule)
model.biogas_constraint = \
    pyo.Constraint(rule=biogas_constraint_rule)
model.adequacy_constraint = \
   pyo.Constraint(model.h, rule=adequacy_constraint_rule)
# Objective -> Cost
model.objective = pyo.Objective(rule=objective_rule)

"""INITIALISATING OUTPUTS"""

model_name = "Upgrade_Outputs"

technologies_definition = {
    # "offshore_f" : "floating offshore wind",
    # "offshore_g" : "ground-based offshore wind",
    "onshore": "onshore wind",
    "pv_g": "pv grounded",
    "pv_c": "pv commercial",
    "river": "run-of-river hydro",
    "lake": "lake and reservoirs",
    "biogas2": "biogas for ccgt",
    "ccgt": "combined cycle gas turbine",
    "nuc": "nuclear",
    "phs": "pumped hydroelectric energy storage",
    "battery4": "4 hours battery",
    # "SC" : "synchronous condenser",
}    

"""SOLVE STATEMENT"""
opt = SolverFactory('gurobi')
opt.options['FeasibilityTol'] = 1e-9
opt.options['OptimalityTol'] = 1e-9
results = opt.solve(model)
"""SET OUTPUTS VARIABLES"""

sumdemand = sum(demand[hour] for hour in model.h) / 1000

gene_tec = {}
for tec in model.tec:
    gene_tec[tec] = sum(pyo.value(model.gene[tec, hour]) for hour in model.h) / 1000
sumgene = sum(pyo.value(model.gene[gen, hour]) for hour in model.h for gen in model.gen) / 1000
reserve = {}


nSTORAGE = {}
for storage in model.str:
    for hour in model.h:
        nSTORAGE[(storage, hour)] = pyo.value(model.storage[storage, hour])

lcoe_sys1 = pyo.value(model.objective) * 1000 / sumgene

str_loss_percent = 100 * (sum(pyo.value(model.storage[storage, hour]) for storage in model.str for hour in model.h) - \
                          sum(gene_tec[storage] * 1000 for storage in model.str)) / (sumgene * 1000)


lc_percent = (100 * (sumgene - sumdemand ) / sumgene) - str_loss_percent
lc_TWh = (sumgene - sumdemand )

spot_price = {}
gas_price1 = {}
gas_price2 = {}
for hour in model.h:
    spot_price[hour] = - 1000000 * model.dual[model.adequacy_constraint[hour]]
    gas_price2[hour] = -1000000 * model.dual[model.combustion_2_constraint[hour]]

marginal_cost = sum(spot_price[hour] for hour in model.h) / (last_hour)

bio_gas_limit_multiplier ={}
for hour in model.h:
    bio_gas_limit_multiplier[hour] = - 1000000 * model.dual[model.biogas_constraint]

"""OUTPUTS
    There is 4 output files :
        - Summary           : A little summary with the cost and some others data
        - Hourly-Generation : Hourly data
        - Elec_Balance      : Electric Production and Consumption
        - Capacities        : List of capacities by technologies"""

"""OUTPUTS
    There is 4 output files :
        - Summary           : A little summary with the cost and some others data
        - Hourly-Generation : Hourly data
        - Elec_Balance      : Electric Production and Consumption
        - Capacities        : List of capacities by technologies"""




# Summary--------------------------------------------------------------------------------------------------------------
cost_dict= {}

cost_dict['total cost bEuro'] = pyo.value(model.objective) / number_of_years
cost_dict['variable cost bEuro'] = pyo.value(variable_cost)/number_of_years
cost_dict['lost load cost bEuro'] = pyo.value(ll_cost)/number_of_years
cost_dict['fixed cost bEuro'] = pyo.value(fixed_cost)/number_of_years

dct1 = {k:[v] for k,v in cost_dict.items()}  # WORKAROUN
df_cost= pd.DataFrame(dct1)
df_cost.to_csv(r'outputs_check_mult/cost_{}_{}_{}.csv'.format(sim_type,n,m))
# Value_Factor---------------------------------------------------------------------------------------------------------




# Hourly_Generation----------------------------------------------------------------------------------------------------
df_VRE_generation = pd.DataFrame()
for vre in model.vre:

 df_VRE_generation[vre] = (capa[vre] * load_factor[vre, :])

df_VRE_generation.to_csv(r"outputs_check_mult/generation_vre_{}_{}_{}.csv".format(sim_type,n, m))



df_generation = pd.DataFrame()

for tec in model.tec_no_vre:
 df_generation[tec] = pyo.value(model.gene[tec,:])


for str in model.str:
  df_generation[str+'soc'] = pyo.value(model.stored[str, :])

for str in model.str:
  df_generation[str+'ch p '] = pyo.value(model.storage[str, :])

df_generation['ll'] = pyo.value(model.ll[:])

#spot_price_df = pd.DataFrame.from_dict(spot_price,orient='columns')

#dct1 = {k:[v] for k,v in spot_price.items()}  # WORKAROUN
#spot_price_df = pd.DataFrame(dct1)
#spot_price_df.to_csv('E:\spot_price_check.csv')

df_price = pd.DataFrame(spot_price.values())
df_biogas_multiplier = pd.DataFrame(bio_gas_limit_multiplier.values())
df_biogas_multiplier.to_csv(r"outputs_check_mult/biogas_mul_{}_{}_{}.csv".format(sim_type,n, m))
df_price.to_csv(r"outputs_check_mult/price_{}_{}_{}.csv".format(sim_type,n, m))
df_generation.to_csv(r"outputs_check_mult/generation_{}_{}_{}.csv".format(sim_type,n, m))
# Elec_balance----------------------------------------------------------------------------------------------------
balance_dict= {}

for tec in model.tec:
    balance_dict[tec] = sum (pyo.value(model.gene[tec,:]))/1000

balance_dict['ll'] = sum (pyo.value(model.ll[:]))/1000


dct1 = {k:[v] for k,v in balance_dict.items()}  # WORKAROUND
df_balance = pd.DataFrame(dct1)

df_balance.to_csv(r'outputs_check_mult/balance_{}_{}_{}.csv'.format(sim_type,n,m))



#sys.stdout.close()
