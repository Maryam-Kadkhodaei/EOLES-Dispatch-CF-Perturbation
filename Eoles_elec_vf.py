"""
Eoles Model from Behrang Shirizadeh, Quentin Perrier and Philippe Quirion, May 2021
Written in Python by Nilam De Oliveira-Gill, June 2021
"""

"""IMPORTS

Import modules and libraries needed for the programm 
"""
import pyomo.environ as pyo
from pyomo.opt import SolverFactory
import pandas as pd
import csv
import time
import sys

#Initialize time to measure the execution time
start_time = time.time()

#We set the name of the model here, it will be used in outputs name
model_name = ""

"""INITIALISATION OF THE MODEL"""

model = pyo.ConcreteModel()

#Dual Variable, used to get the marginal value of an equation.
model.dual = pyo.Suffix(direction=pyo.Suffix.IMPORT)

"""INPUTS"""

    # Production profiles of VRE
load_factor = pd.read_csv("inputs/vre_profiles2006new.csv", index_col=[0, 1], squeeze=True, header=None)
    # Demand profile in each our in GW
demand = pd.read_csv("inputs/demand2050_RTE.csv",index_col=0, squeeze=True, header=None)
    # Monthly lake inflows in GWh
lake_inflows = pd.read_csv("inputs/lake2006.csv", index_col=0, squeeze=True, header=None)
    # Additional FRR requirement for variable renewable energies because of forecast errors
epsilon = pd.read_csv("inputs/reserve_requirements_new.csv", index_col=0, squeeze=True, header=None)
    # Existing capacities of the technologies by December 2017 in GW
capa_ex = pd.read_csv("inputs/existing_capas_elec_new.csv", index_col=0, squeeze=True, header=None)
    # Maximum capacities of the technologies in GW
capa_max = pd.read_csv("inputs/max_capas_elec_new.csv", index_col=0, squeeze=True, header=None)
    # Fixed capacities of the technologies in GW
fix_capa = pd.read_csv("inputs/fix_capas.csv", index_col=0, squeeze=True, header=None)
    # Annualized power capex cost in M€/GW/year
capex = pd.read_csv("inputs/annuities_elec_new.csv", index_col=0, squeeze=True, header=None)
    # Annualized energy capex cost of storage technologies in M€/GWh/year
capex_en = pd.read_csv("inputs/str_annuities_elec_new.csv", index_col=0, squeeze=True, header=None)
    # Annualized fixed operation and maintenance costs M€/GW/year
fOM = pd.read_csv("inputs/fO&M_elec_new.csv", index_col=0, squeeze=True, header=None)
    # Variable operation and maintenance costs in M€/GWh
vOM = pd.read_csv("inputs/vO&M_elec_new.csv", index_col=0, squeeze=True, header=None)
    # Charging related annuity of storage in M€/GW/year
s_capex = pd.read_csv("inputs/s_capex.csv", index_col=0, squeeze=True, header=None)
    # Charging related fOM of storage in M€/GW/year
s_opex = pd.read_csv("inputs/s_opex.csv", index_col=0, squeeze=True, header=None)
    # Charging efficiency of storage technologies
eta_in = pd.read_csv("inputs/eta_in.csv", index_col=0, squeeze=True, header=None)
    # Discharging efficiency of storage technolgoies
eta_out = pd.read_csv("inputs/eta_out.csv", index_col=0, squeeze=True, header=None)
    # Existing storage capacity in GWh
capacity_ex = pd.read_csv("inputs/capacity_ex.csv", index_col=0, squeeze=True, header=None)
    #Parameters in miscellaneous.csv :
        # eta_ocgt                  : efficiency of OCGT power plants
        # eta_ccgt                  : efficiency of CCGT power plants with CCS
        # max_biogas                : maximum energy can be generated by biogas in TWh
        # load_uncertainty          : uncertainty coefficient for hourly demand
        # delta                     : load variation factor
        # H2_demand                 : hourly hydrogen demand on top of the storage
        # eta_electrolysis          : efficiency of Electrolysis
        # phs_discharging_lower     : lower bounds for capa(phs)
        # phs_discharging_upper     : upper bounds for capa(phs)
        # phs_charging_lower        : lower bounds for s(phs) 
        # phs_charging_upper        : upper bounds for s(phs)
        # phs_energy_lower          : lower bounds for capacity(phs)
        # phs_energy_upper          : upper bounds for capacity(phs)
        # first_month               : first month of demand
        # first_year                : first year of demand

miscellaneous = pd.read_csv("inputs/miscellaneous.csv",index_col=0,squeeze=True,header=None)

"""SET HOUR BY MONTHS

Take the number of hour in the demand file.
Set up hours per months."""

first_year = miscellaneous['first_year']
first_month = miscellaneous['first_month']
first_hour = 0
last_hour = len(demand)
days_in_feb = 672

hours_by_months = {1: 744, 2: days_in_feb, 3: 744, 4: 720, 5: 744, 6: 720, 7: 744, 8: 744, 9: 720, 10: 744, 11: 720, 12: 744}
months_hours = {1: range(0, 744), 2: range(744, 1440), 3: range(1440, 2184), 4: range(2184, 2904),
                5: range(2904, 3648), 6: range(3648, 4368), 7: range(4368, 5112),
                8: range(5112, 5856), 9: range(5856, 6576), 10: range(6576, 7320), 11: range(7320, 8040),
                12: range(8039, last_hour)}
i = 1
j = first_month
hour = 0
while i <= 12:
    if i == 12:
        months_hours[i] = range(hour,last_hour)
    else:
        months_hours[i] = range(hour,hour+hours_by_months[j])
    hour += hours_by_months[j]
    j += 1
    i += 1
    if j == 13:
        j = 1

"""SETS

Definition of set as an object of the model
"""

#Range of hour in one year
model.h = \
    pyo.RangeSet(first_hour,last_hour-1)
#Months
model.months = \
    pyo.RangeSet(1,12)
#Technologies
model.tec = \
    pyo.Set(initialize=["offshore_f", "offshore_g", "onshore", "pv_g", "pv_c", "river", "lake", "biogas1", "biogas2", "ocgt", "ccgt", "nuc", "h2_ccgt", "phs",  "battery1", "battery4", "electrolysis", "hydrogen", "SC"])
#Power plants
model.gen = \
    pyo.Set(initialize=["offshore_f", "offshore_g", "onshore", "pv_g", "pv_c", "river", "lake","ocgt","ccgt","nuc"])
#Variables Technologies
model.vre = \
    pyo.Set(initialize=["offshore_f", "offshore_g", "onshore", "pv_g", "pv_c", "river"])
#
model.balance = \
    pyo.Set(initialize=["offshore_f", "offshore_g", "onshore", "pv_g", "pv_c", "river", "lake","nuc","phs","battery1","battery4","h2_ccgt","ocgt","ccgt"])
#Storage Technologies
model.str = \
    pyo.Set(initialize=["phs", "battery1","battery4", "hydrogen"])
#Storage Technologies
model.str_noH2 = \
    pyo.Set(initialize=["phs", "battery1","battery4"])
#Battery Storage
model.battery = \
    pyo.Set(initialize=["battery1","battery4"])
#Technologies for upward FRR
model.frr = \
    pyo.Set(initialize=["lake", "phs", "ocgt","ccgt","nuc","h2_ccgt","SC"])

"""PARAMETERS"""

#Set the hydrogen demand for each hour
H2_demand = {}
for hour in model.h:
    H2_demand[hour] = miscellaneous['H2_demand']


"""BOUNDS VALUES

Set initial value for variables.
There is a function for each variable with bounds.
The function return the lower and the upper value.
"""

def capa_bounds(model,i):
    if i in capa_max.keys():
        return (None,capa_max[i])
    elif i == 'phs' :
        return (miscellaneous['phs_discharging_lower'],miscellaneous['phs_discharging_upper'])
    else :
        return(None,None)

def s_bounds(model,i):
    if i == 'phs' :
        return (miscellaneous['phs_charging_lower'],miscellaneous['phs_charging_upper'])
    else :
        return (None,None)

def capacity_bounds(model,i):
    if i == 'phs' :
        return (miscellaneous['phs_energy_lower'],miscellaneous['phs_energy_upper'])
    elif i == 'hydrogen' :
        return (capacity_ex['hydrogen'],None)
    else :
        return (None,None)

"""VARIABLES

Definition of variable as an object of the model
"""

    # Hourly energy generation in GWh/h
model.gene = \
    pyo.Var(((tec, h) for tec in model.tec for h in model.h), within=pyo.NonNegativeReals,initialize=0)

    # Overall yearly installed capacity in GW
model.capa = \
    pyo.Var(model.tec, within=pyo.NonNegativeReals, initialize=0,bounds=capa_bounds)

    # Hourly electricity input of battery storage GW
model.storage = \
    pyo.Var(((storage, h) for storage in model.str for h in model.h), within=pyo.NonNegativeReals,initialize=0)

    # Energy stored in each storage technology in GWh = Stage of charge
model.stored = \
    pyo.Var(((storage, h) for storage in model.str for h in model.h), within=pyo.NonNegativeReals,initialize=0)

    # Charging power capacity of each storage technology
model.s = \
    pyo.Var(model.str, within=pyo.NonNegativeReals, initialize=0,bounds=capa_bounds)

    # Energy volume of storage technology in GWh
model.capacity = \
    pyo.Var(model.str, within=pyo.NonNegativeReals, initialize=0,bounds = capacity_bounds)

    # Required upward frequency restoration reserve in GW    
model.reserve = \
    pyo.Var(((reserve, h) for reserve in model.frr for h in model.h), within=pyo.NonNegativeReals,initialize=0)

"""FIXED VALUES"""

for tec in model.tec:
    if tec in fix_capa.keys():
        model.capa[tec].fix(fix_capa[tec])

"""CONSTRAINTS RULE

Set up a function which will return the equation of the constraint.
"""

def generation_vre_constraint_rule(model, h, vre):
    """Get constraint on variables renewable profiles generation."""

    return model.gene[vre, h] == model.capa[vre] * load_factor[vre,h]

def generation_capacity_constraint_rule(model, h, tec):
    """Get constraint on maximum power for non-VRE technologies."""

    return model.capa[tec] >= model.gene[tec,h]

def battery1_capacity_constraint_rule(model):
    """Get constraint on capacity of battery1."""

    return model.capa['battery1'] == model.capacity['battery1']

def battery4_capacity_constraint_rule(model):
    """Get constraint on capacity of battery4."""

    return model.capa['battery4'] == model.capacity['battery4']/4

def combustion_1_constraint_rule(model, h):
    """Get constraint on the relationship of combustible technologies"""

    return model.gene['ocgt', h] == model.gene['biogas1',h]*miscellaneous['eta_ocgt']

def combustion_2_constraint_rule(model, h):
    """Get constraint on the relationship of combustible technologies"""

    return model.gene['ccgt', h] == model.gene['biogas2',h]*miscellaneous['eta_ccgt']

def frr_capacity_constraint_rule(model, h, frr):
    """Get constraint on maximum generation including reserves"""

    return model.capa[frr] >= model.gene[frr, h] + model.reserve[frr, h]

def storing_constraint_rule(model, h, storage_tecs):
    """Get constraint on storing."""

    hPOne = h+1 if h<(last_hour-1) else 0
    charge = model.storage[storage_tecs, h] * eta_in[storage_tecs]
    discharge =  model.gene[storage_tecs, h] / eta_out[storage_tecs]
    flux = charge - discharge
    return model.stored[storage_tecs, hPOne] == model.stored[storage_tecs, h] + flux

def storage_constraint_rule(model,storage_tecs):
    """Get constraint on stored energy to be equal at the end than at the start."""

    first = model.stored[storage_tecs, first_hour]
    last = model.stored[storage_tecs, last_hour-1]
    charge = model.storage[storage_tecs, last_hour-1] * eta_in[storage_tecs]
    discharge = model.gene[storage_tecs, last_hour-1] / eta_out[storage_tecs]
    flux = charge - discharge
    return first == last + flux

def lake_reserve_constraint_rule(model, month):
    """Get constraint on maximum monthly lake generation."""

    return sum(model.gene['lake', hour] for hour in months_hours[month]) <= lake_inflows[month] * 1000

def stored_capacity_constraint(model, h, storage_tecs):
    """Get constraint on maximum energy that is stored in storage units"""

    return model.stored[storage_tecs, h] <= model.capacity[storage_tecs]

def storage_capacity_1_constraint_rule(model, h, storage_tecs):
    """Get constraint on the capacity with hourly charging relationship of storage"""

    return model.s[storage_tecs] >= model.storage[storage_tecs, h]

def battery_capacity_constraint_rule(model,battery):
    """Get constraint on battery's capacity."""

    return model.s[battery] == model.capa[battery]

def biogas_constraint_rule(model):
    """Get constraint on biogas."""

    gene_biogas = sum(model.gene['biogas1', hour]+model.gene['biogas2',hour] for hour in model.h)

    return gene_biogas <= miscellaneous['max_biogas'] * 1000

def hydrogen_balance_constraint_rule(model,h):
    """Get constraint on hydrogen's balance."""

    gene_e_h = model.gene['electrolysis',h]+model.gene['hydrogen',h]
    dem_sto = model.gene['h2_ccgt',h]/miscellaneous['eta_h2_ccgt'] + H2_demand[h] + model.storage['hydrogen',h]
    return gene_e_h == dem_sto

def reserves_constraint_rule(model, h):
    """Get constraint on water for lake reservoirs."""

    res_req = sum(epsilon[vre] * model.capa[vre] for vre in model.vre)
    load_req = demand[h] * miscellaneous['load_uncertainty'] * (1 + miscellaneous['delta'])
    return sum(model.reserve[frr, h] for frr in model.frr) ==  res_req + load_req

def adequacy_constraint_rule(model, h):
    """Get constraint for 'supply/demand relation'"""

    sto = sum(model.storage[str_noH2, h] for str_noH2 in model.str_noH2)
    gene_electrolysis = model.gene['electrolysis',h] / miscellaneous['eta_electrolysis']
    return sum(model.gene[balance, h] for balance in model.balance) >= (demand[h] + sto + gene_electrolysis)

def objective_rule(model):
    """Get constraint for the final objective function."""

    return (sum((model.capa[tec] - capa_ex[tec]) * capex[tec] for tec in model.tec) \
           + sum((model.capacity[storage_tecs]-capacity_ex[storage_tecs]) * capex_en[storage_tecs] for storage_tecs in model.str)\
           + sum(model.capa[tec] * fOM[tec] for tec in model.tec)\
           + sum(model.s[storage_tecs] * (s_opex[storage_tecs] + s_capex[storage_tecs]) for storage_tecs in model.str)\
           + sum(sum(model.gene[tec, h] * vOM[tec] for h in model.h) for tec in model.tec))/1000

"""CONSTRAINT CREATION

Create the constraint as an object of the model with the function declared earlier as a rule.
"""

model.generation_vre_constraint = \
    pyo.Constraint(model.h, model.vre, rule=generation_vre_constraint_rule)

model.generation_capacity_constraint = \
    pyo.Constraint(model.h, model.tec, rule=generation_capacity_constraint_rule)

model.battery_1_capacity_constraint = \
    pyo.Constraint(rule=battery1_capacity_constraint_rule)

model.battery_4_capacity_constraint = \
    pyo.Constraint(rule=battery4_capacity_constraint_rule)

model.combustion_1_constraint = \
    pyo.Constraint(model.h, rule=combustion_1_constraint_rule)

model.combustion_2_constraint = \
    pyo.Constraint(model.h, rule=combustion_2_constraint_rule)

model.frr_capacity_constraint = \
    pyo.Constraint(model.h, model.frr, rule=frr_capacity_constraint_rule)

model.storing_constraint = \
    pyo.Constraint(model.h,model.str, rule=storing_constraint_rule)

model.storage_constraint = \
    pyo.Constraint(model.str, rule=storage_constraint_rule)

model.lake_reserve_constraint = \
    pyo.Constraint(model.months, rule=lake_reserve_constraint_rule)

model.stored_capacity_constraint = \
    pyo.Constraint(model.h, model.str, rule=stored_capacity_constraint)

model.storage_capacity_1_constraint = \
    pyo.Constraint(model.h, model.str, rule=storage_capacity_1_constraint_rule)

model.battery_capacity_constraint = \
    pyo.Constraint(model.battery, rule=battery_capacity_constraint_rule)

model.biogas_constraint = \
    pyo.Constraint(rule=biogas_constraint_rule)

model.hydrogen_balance_contraint = \
    pyo.Constraint(model.h,rule=hydrogen_balance_constraint_rule)

model.reserves_constraint = \
    pyo.Constraint(model.h, rule=reserves_constraint_rule)

model.adequacy_constraint = \
    pyo.Constraint(model.h, rule=adequacy_constraint_rule)

#Creation of the objective -> Cost
model.objective = pyo.Objective(rule=objective_rule)

"""SOLVE STATEMENT

Choice of the solver.
You can remove the '#' in the third line to display the output of the solver.
"""

opt = SolverFactory('gurobi')
results = opt.solve(model)
#model.display()

"""SET OUTPUTS VARIABLES"""

#Dictionnary which will set a little definition for each technology in the model.
technologies_definition = {
    "offshore_f" : "floating offshore wind",
    "offshore_g" : "ground-based offshore wind",
    "onshore" : "onshore wind",
    "pv_g" : "pv grounded",
    "pv_c" : "pv commercial",
    "river" : "run-of-river hydro",
    "lake" : "lake and reservoirs",
    "biogas1" : "biogas for ocgt",
    "biogas2" : "biogas for ccgt",
    "ocgt" : "open cycle gas-turbine",
    "ccgt" : "combined cycle gas turbine",
    "nuc" : "nuclear",
    "h2_ccgt" : "combined cycle gas turbine using hydrogen",
    "phs" : "pumped hydroelectric energy storage",
    "battery1" : "1 hour battery",
    "battery4" : "4 hours battery",
    "electrolysis" : "electrolysis",
    "hydrogen" : "hydrogen removed from storage",
    "SC" : "synchronous condenser",
}

    # The whole demand per year in TWh
sumdemand = sum(demand[hour] for hour in model.h) / 1000
    # The whole electricity demand for hydrogen per year in TWh
dem_hydrogen = sum(H2_demand[hour] for hour in model.h) / 1000
    # The whole generation per year in TWh
sumgene = sum(pyo.value(model.gene[gen,hour]) for hour in model.h for gen in model.gen) / 1000
    # The whole energy budgeted for reserves per year in TWh
sum_FRR = sum(pyo.value(model.reserve[frr,hour]) for hour in model.h for frr in model.frr) / 1000

    # Overall yearly energy generated by the technology in TWh
gene_tec = {}
for tec in model.tec:
    gene_tec[tec] = sum(pyo.value(model.gene[tec,hour]) for hour in model.h) / 1000

    # Capacity allocated for reserve from each FRR technology in GW
reserve = {}
for frr in model.frr:
    reserve[frr] = sum(pyo.value(model.reserve[frr,hour]) for hour in model.h)

    # The whole electricity input for storage per year in TWh
nSTORAGE = {}
for storage in model.str:
    for hour in model.h:
        nSTORAGE[(storage,hour)] = pyo.value(model.storage[storage,hour])

    # Electricity cost per MWh produced (euros/MWh)
lcoe_sys1 = pyo.value(model.objective)*1000/sumgene

    # Yearly storage related loss in % of power production and in TWh
str_loss_percent = 100*(sum(pyo.value(model.storage[storage,hour]) for storage in model.str for hour in model.h)-\
sum(gene_tec[storage]*1000 for storage in model.str)) / (sumgene*1000)
str_loss_TWh = gene_tec['electrolysis']/miscellaneous['eta_electrolysis'] - dem_hydrogen/miscellaneous['eta_electrolysis'] - gene_tec['h2_ccgt']
for storage in model.str:
    if storage != 'hydrogen' :
        str_loss_TWh += sum(nSTORAGE[storage,hour] for hour in model.h)/1000 - gene_tec[storage]

    # Load curtailment in % of power production and in TWh
lc_percent = (100*(sumgene - sumdemand - dem_hydrogen/0.75)/sumgene) - str_loss_percent
lc_TWh = (sumgene - sumdemand - dem_hydrogen/0.75) - str_loss_TWh

    # Dual values
spot_price = {}
gas_price1 = {}
gas_price2 = {}
for hour in model.h:
    spot_price[hour] = - 1000000 * model.dual[model.adequacy_constraint[hour]]
    gas_price2[hour] = -1000000 * model.dual[model.combustion_2_constraint[hour]]
    gas_price1[hour] = -1000000 * model.dual[model.combustion_1_constraint[hour]]

    # Marginal Cost
marginal_cost = sum(spot_price[hour] for hour in model.h) / (last_hour)

    # Average cost of hydrogen (euros/kg)
lcoh_1 = pyo.value(model.capa['electrolysis'])*(capex['electrolysis']+fOM['electrolysis'])
lcoh_2 =  sum(pyo.value(model.gene['electrolysis',hour])*(vOM['electrolysis']+\
    (spot_price[hour]/1000)) for hour in model.h)
lcoh_3 = capex_en['hydrogen']*pyo.value(model.capacity['hydrogen'])
lcoh_4 = sum(pyo.value(model.gene['electrolysis',hour]) for hour in model.h)
lcoh = (lcoh_1 + lcoh_2 + lcoh_3)*33.33 / lcoh_4
    # Electricity cost per MWh consumed (euros/MWh)
lcoe_sys2 = (pyo.value(model.objective)-(lcoh*dem_hydrogen/33.33))*1000/sumdemand


"""OUTPUTS
    There is 4 output files :
        - Summary           : A little summary with the cost and some others data
        - Hourly-Generation : Hourly data
        - Elec_Balance      : Electric Production and Consumption
        - Capacities        : List of capacities by technologies

The try, except loop is here the manage error in the creation of the outputs.
"""

#Summary
summary_file = "outputs/eoles_" + model_name + "_summary.csv"
try:
    with open(summary_file,"w",newline="") as summary:
        summary_writer = csv.writer(summary)

        summary_header = ["COST","LCOH","LCOE_SYS1","LCOE_SYS2","STR_LOSS","LC"]
        summary_writer.writerow(summary_header)

        summary_definition = [
            "in billion euro",
            "average cost of hydrogen (euros/kg)",
            "electricity cost per MWh produced (euros/MWh)",
            "electricity cost per MWh consumed (euros/MWh)",
            "yearly storage related loss in % of power production",
            "load curtailment in % of power production"]
        summary_writer.writerow(summary_definition)

        summary_data = [
            round(pyo.value(model.objective),2),
            round(lcoh,2),
            round(lcoe_sys1,2),
            round(lcoe_sys2,2),
            round(str_loss_percent,2),
            round(lc_percent,2),]
        summary_writer.writerow(summary_data)
except Exception as e:
    if e.args == (13, 'Permission denied') :
        sys.stderr.write("Error : Permission Denied")
        print("Error : Permission Denied. Maybe try to close the file : ",summary_file) 
    else : 
        print("There is an Error (summary) :",e.args)

#Hourly_Generation
hourly_file = "outputs/eoles_" + model_name + "_hourly_generation.csv"
try:
    with open(hourly_file,"w",newline="") as hourly:
        hourly_writer = csv.writer(hourly)

        hourly_title = ["","Generation ->"]
        for i in range(1,len(model.tec)-3):
            hourly_title.append("")
        hourly_title += [
            "Consumption ->","","","",
            "Storage input ->","","","",
            "State of charge ->","","","",
            "Dual Value",
            "Reserves ->"
            ]
        hourly_writer.writerow(hourly_title)

        hourly_header = ["hour"]
        for tec in model.tec:
            hourly_header.append(tec)
        hourly_header += [
            "electricity_demand",
            "pump",
            "elecStr1",
            "elecStr4",
            "hydrogen",
            "pump",
            "elecStr1",
            "elecStr4",
            "hydrogen",
            "elec balance",]
        for rsv in model.frr:
            hourly_header.append(rsv)
        hourly_writer.writerow(hourly_header)

        hourly_definition = [""]
        for tec_def in technologies_definition:
            #if tec_def != "SC":
            hourly_definition.append(technologies_definition.get(tec_def))
        hourly_definition += [
            "electricity_demand",
            "phs","battery1","battery4","hydrogen",
            "phs","battery1","battery4","hydrogen",
            ""]
        for rsv in model.frr:
            hourly_definition.append(technologies_definition.get(rsv))
        hourly_writer.writerow(hourly_definition)

        hourly_units = [""]
        hourly_units += [
            "GWh-e","GWh-e","GWh-e","GWh-e","GWh-e","GWh-e","GWh-e",
            "GWh-th","GWh-th","GWh-e","GWh-e","GWh-e","GWh-e",
            "GWh-e","GWh-e","GWh-e","GWh-e","GWh-th",
            "GW",
            "GWe","GWe","GWe","GWth",
            "GWe","GWe","GWe","GWth",
            "Euros/MWe"
            ]
        hourly_writer.writerow(hourly_units)

        for hour in model.h:
            hourly_data = [hour]

            for tec in model.tec:
                #if tec != 'SC' :
                hourly_data.append(round(pyo.value(model.gene[tec,hour]),2))

            hourly_data.append(round(demand[hour],2))

            for storage_tecs in model.str:
                hourly_data.append(round(pyo.value(model.storage[storage_tecs,hour]),2))
            
            for storage_tecs in model.str:
                hourly_data.append(round(pyo.value(model.stored[storage_tecs,hour]),2))

            hourly_data.append(round(spot_price[hour],2))
            for frr in model.frr:
                hourly_data.append(round(pyo.value(model.reserve[frr,hour]),2))
            hourly_writer.writerow(hourly_data)
except Exception as e:
    if e.args == (13, 'Permission denied') :
        sys.stderr.write("Error : Permission Denied")
        print("Error : Permission Denied. Maybe try to close the file : ",hourly_file) 
    else : 
        print("There is an Error (hourly) :",e.args)

#Elec_balance
elec_balance_file = "outputs/eoles_" + model_name + "_elec_balance.csv"
try:
    with open(elec_balance_file,"w",newline="") as balance:
        balance_writer = csv.writer(balance)

        balance_title = ["Supply in TWh-e ->"]
        balance_writer.writerow(balance_title)
        balance_tec_minus = ['biogas1','biogas2','hydrogen','electrolysis']
        balance_header = []
        for tec in model.tec:
            if tec not in balance_tec_minus:
                balance_header.append(tec)
        balance_writer.writerow(balance_header)
        balance_definition = []
        for tec in technologies_definition:
            if tec not in balance_tec_minus:
                balance_definition.append(technologies_definition.get(tec))
        balance_writer.writerow(balance_definition)
        balance_data = []
        for tec in technologies_definition:
            if tec not in balance_tec_minus:
                balance_data.append(round(pyo.value(gene_tec[tec]),2))
        balance_writer.writerow(balance_data)
        ################################################
        balance_writer.writerow([])
        balance_title = ["Use in TWh-e ->"]
        balance_writer.writerow(balance_title)
        balance_header = ['electrolysis']
        for tec in model.str:
            if tec != 'hydrogen':
                balance_header.append(tec)
        balance_header += ["elec demand","load curtailment"]
        balance_writer.writerow(balance_header)
        balance_data = [round(pyo.value(gene_tec['electrolysis'])/miscellaneous['eta_electrolysis'],2)]
        for tec in model.str:
            if tec != 'hydrogen':
                balance_data.append(round(sum(nSTORAGE[tec,hour] for hour in model.h)/1000,2))
        balance_data += [round(sumdemand,2),round(lc_TWh,2)]
        balance_writer.writerow(balance_data)
        #################################################
        balance_writer.writerow([])
        balance_title = ["Miscellaneous->"]
        balance_writer.writerow(balance_title)
        balance_tec = ['str_loss','hydrogen production','h2_demand','biogas1','biogas2']
        balance_writer.writerow(balance_tec)
        balance_def = ['yearly storage related loss',
        'hydrogen removed from storage','elec for h2 demand',
        'biogas for ocgt','biogas for ccgt']
        balance_writer.writerow(balance_def)
        balance_units = ["TWh-e","TWh-th","TWh-e","TWh-th","TWh-th"]
        balance_writer.writerow(balance_units)
        balance_data = [round(str_loss_TWh,2),round(pyo.value(gene_tec['hydrogen']),2),
        round((dem_hydrogen/miscellaneous['eta_electrolysis']),2),round(pyo.value(gene_tec['biogas1']),2),
        round(pyo.value(gene_tec['biogas2']),2)]
        balance_writer.writerow(balance_data)
        #####################################################
        balance_writer.writerow([])
        balance_title = ["Capacity Factor in % ->"]
        balance_writer.writerow(balance_title)
        balance_tec = ['lake','ocgt','ccgt','nuc','h2_ccgt','SC']
        balance_writer.writerow(balance_tec)
        balance_data = []
        for tec in model.frr:
            if tec != 'phs':
                if pyo.value(model.capa[tec])*1000/8760*100 == 0:
                    capa = "-"
                else:
                    capa = round(gene_tec[tec]/pyo.value(model.capa[tec])*1000/8760*100,2)
                balance_data.append(capa)
        balance_writer.writerow(balance_data)
        ##################################################
except Exception as e:
    if e.args == (13, 'Permission denied') :
        sys.stderr.write("Error : Permission Denied")
        print("Error : Permission Denied. Maybe try to close the file : ",elec_balance_file) 
    else : 
        print("There is an Error (balance) :",e.args)

#Capacities
capacities_file = "outputs/eoles_" + model_name + "_capacities.csv"
try:
    with open(capacities_file,"w",newline="") as capacities:
        capacities_writer = csv.writer(capacities)
        ################################################################
        capacities_title = ["Capacity in GW ->"]
        capacities_writer.writerow(capacities_title)
        capacities_header = []
        for tec in model.tec:
            capacities_header.append(tec)
        capacities_writer.writerow(capacities_header)
        capacities_definition = []
        for tec_def in technologies_definition:
            capacities_definition.append(technologies_definition.get(tec_def))
        capacities_writer.writerow(capacities_definition)
        capacities_data = []
        for tec in model.tec:
            capacities_data.append(round(pyo.value(model.capa[tec]),2))
        capacities_writer.writerow(capacities_data)
        ################################################################
        capacities_writer.writerow([])
        capacities_title = ["Energy volume of storage technology in GWh ->"]
        capacities_writer.writerow(capacities_title)
        capacities_header = []
        for storages_tecs in model.str:
            capacities_header.append(storages_tecs)
        capacities_writer.writerow(capacities_header)
        capacities_definition = []
        for str_def in model.str:
            capacities_definition.append(technologies_definition.get(str_def))
        capacities_writer.writerow(capacities_definition)
        capacities_data = []
        for storages_tecs in model.str:
            capacities_data.append(round(pyo.value(model.capacity[storages_tecs]),2))
        capacities_writer.writerow(capacities_data)
except Exception as e:
    if e.args == (13, 'Permission denied') :
        sys.stderr.write("Error : Permission Denied")
        print("Error : Permission Denied. Maybe try to close the file : ",capacities_file) 
    else : 
        print("There is an Error (capacities) :",e.args)

print("Execution time (in seconds) : ",(time.time() - start_time))
